// Effect Syntax Guide: https://docs.cocos.com/creator/manual/zh/shader/index.html

CCEffect %{
  techniques:
  - name: opaque
    passes:
    - vert: unlit-vs:vert # builtin header
      frag: unlit-fs:frag
      properties: &props
        mainTexture:    { value: white }
        mainColor:      { value: [1, 1, 1, 1], editor: { type: color } }

        lutTexture:    { value: white }
  - name: transparent
    passes:
    - vert: unlit-vs:vert # builtin header
      frag: unlit-fs:frag
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendSrcAlpha: src_alpha
          blendDstAlpha: one_minus_src_alpha
      properties: *props
}%

CCProgram unlit-vs %{
  precision highp float;
  #include <legacy/input-standard>
  #include <builtin/uniforms/cc-global>
  #include <legacy/local-batch>
  #include <legacy/input-standard>

  in vec4 a_color;

  out vec3 v_position;
  out vec3 v_normal;
  out vec3 v_tangent;
  out vec3 v_bitangent;
  out vec2 v_uv;
  out vec4 v_color;
  out vec4 v_screenPos;

  vec4 vert () {
    StandardVertInput In;
    CCVertInput(In);

    mat4 matWorld, matWorldIT;
    CCGetWorldMatrixFull(matWorld, matWorldIT);

    vec4 pos = matWorld * In.position;

    v_position = pos.xyz;
    v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);
    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);
    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w; // note the cross order

    v_uv = a_texCoord;
    v_color = a_color;

    #if SAMPLE_FROM_RT
      CC_HANDLE_RT_SAMPLE_FLIP(v_uv);
    #endif

    v_screenPos = cc_matProj * (cc_matView * matWorld) * In.position;

    return vec4(sign(In.position.x), sign(In.position.y), 0.0, 1.0);
  }

}%

CCProgram unlit-fs %{
  precision highp float;
  #include <legacy/output>

  in vec2 v_uv;
  in vec3 v_position;
  in vec4 v_screenPos;

  uniform sampler2D mainTexture;
  uniform sampler2D lutTexture;

  uniform Constant {
    vec4 mainColor;
  };

  vec4 frag () {
    vec4 color = mainColor * texture(mainTexture, v_uv);

    float pixelSize = 512.0;  //512x512图片大小
    float gridPixel = 64.0;   //格子的像素大小
    float maxIndex = gridPixel - 1.0;  //最大索引
    float row = 8.0, col = 8.0;  //行列数
    float maxRowIndex = row - 1.0, maxColIndex = col - 1.0;  //最大行列索引

    //计算当前像素所在的格子索引
    float gIndex = color.b * maxIndex;
    //因为有可能是在两个格子之间，分别向上和向下取，再混合
    vec2 gridIndex1;
    gridIndex1.y = floor(floor(gIndex) / col);
    gridIndex1.x = floor(gIndex) - gridIndex1.y * row;

    vec2 gridIndex2;
    gridIndex2.y = floor(min(ceil(gIndex), maxIndex) / col);
    gridIndex2.x = min(ceil(gIndex), maxIndex) - gridIndex2.y * row;

    float gridTexel = gridPixel / pixelSize;  //格子的纹理像素大小
    float halfTexel = 0.5 / pixelSize;  //半个像素大小

    //获取格子1的uv
    vec2 uv1;
    uv1.x = gridIndex1.x * gridTexel + color.r * gridTexel + halfTexel;
    uv1.y = gridIndex1.y * gridTexel + color.g * gridTexel + halfTexel;

    //获取格子2的uv
    vec2 uv2;
    uv2.x = gridIndex2.x * gridTexel + color.r * gridTexel + halfTexel;
    uv2.y = gridIndex2.y * gridTexel + color.g * gridTexel + halfTexel;

    vec3 color1 = texture(lutTexture, uv1).rgb;
    vec3 color2 = texture(lutTexture, uv2).rgb;
    float ratio = gIndex - floor(gIndex);
    vec4 finalColor = vec4(mix(color1, color2, ratio), 1.0);

    return CCFragOutput(finalColor);
  }
}%
